# Game Architecture Document: เกมเรียนรู้ภาวะเงินเฟ้อ

**เวอร์ชัน:** 1.0

---

# 1. ภาพรวมสถาปัตยกรรมและเทคโนโลยี (Architecture Overview & Tech Stack)

## 1.1. ปรัชญาการออกแบบ (Architectural Philosophy)
สถาปัตยกรรมของเกมนี้จะเน้นความยืดหยุ่น, ง่ายต่อการปรับแก้และต่อยอด (Scalability & Modularity) โดยจะยึดหลักการ Component-Based ของ Unity เป็นหัวใจหลักในการออกแบบ ทุกระบบจะถูกสร้างเป็นส่วนประกอบ (Component) ที่สามารถนำกลับมาใช้ใหม่และทดสอบได้ง่าย เพื่อให้การพัฒนารวดเร็วและลดข้อผิดพลาด

## 1.2. เทคโนโลยีหลัก (Core Technology Stack)
- **Game Engine:** Unity 2023.x (LTS)
- **Programming Language:** C# (เวอร์ชัน 11)
- **Platform เป้าหมาย:** PC (Windows, macOS) และ Web (WebAssembly/WebGL)
- **Version Control:** Git

## 1.3. การจัดการข้อมูล (Data Management)
- **ScriptableObjects:** จะถูกใช้อย่างแพร่หลายในการจัดการข้อมูลของเกมที่ไม่เปลี่ยนแปลงบ่อย (Game Data) เช่น ข้อมูลคอร์สเรียน, ระดับของงาน, หรือข้อมูลไอเท็มต่างๆ เพื่อแยกข้อมูล (Data) ออกจากตรรกะของเกม (Logic) ทำให้ง่ายต่อการปรับสมดุลเกมในอนาคต
- **JSON/Binary Serialization:** สำหรับการบันทึกข้อมูลของผู้เล่น (Save/Load Game State) เช่น ค่าสถานะปัจจุบัน, ทรัพย์สิน, และความคืบหน้าของเกม

---

# 2. สถาปัตยกรรมระบบหลัก (Core Systems Architecture)

## 2.1. ระบบจัดการเกม (Game Manager & State Machine)
- จะมี **GameManager** เป็นคลาสศูนย์กลางที่ควบคุมสถานะโดยรวมของเกม (เช่น Main Menu, Planning Phase, Game Playing, Paused, Game Over)
- ใช้ State Machine Pattern ในการจัดการการเปลี่ยนผ่านระหว่างสถานะต่างๆ เพื่อให้ควบคุม Flow ของเกมได้ง่าย

## 2.2. ระบบจัดการเวลาและเทิร์น (Time & Turn Management)
- **TurnManager:** คลาสที่รับผิดชอบการจัดการวัฏจักรรายสัปดาห์, งบเวลา (Time Budget) ของผู้เล่น
- จะมีการส่งอีเวนต์ (Broadcast Events) เช่น `OnWeekStart`, `OnWeekEnd` เพื่อให้ระบบอื่นๆ รับรู้และทำงานตามช่วงเวลา

## 2.3. ระบบจัดการค่าสถานะผู้เล่น (Player Stats System)
- **PlayerStatsController:** คลาสสำหรับจัดการค่าสถานะหลักทั้ง 4 บาร์ และค่าความเครียด
- จะมีฟังก์ชันสาธารณะ (Public Methods) เช่น `AddMoney(float amount)`, `ApplyStress(float amount)`
- ข้อมูลสถานะจะถูกเก็บในคลาส `PlayerData` แยกต่างหาก เพื่อให้ง่ายต่อการบันทึกและโหลดเกม

## 2.4. ระบบเงินเฟ้อ (Inflation System)
- **InflationManager:** คลาสที่จัดการ `อัตราเงินเฟ้อ` ของเกมโดยเฉพาะ
- จะทำการอัปเดตอัตราเงินเฟ้อเป็นระยะ และส่งอีเวนต์ `OnInflationChanged`
- ระบบอื่นๆ เช่น ร้านค้า, ค่าครองชีพ จะดักฟังอีเวนต์นี้เพื่ออัปเดตราคาของตัวเอง

## 2.5. ระบบอีเวนต์กลาง (Global Event System)
- จะใช้ระบบอีเวนต์เพื่อการสื่อสารระหว่างระบบต่างๆ โดยไม่ต้องอ้างอิงถึงกันโดยตรง (Decoupling) เพื่อลดความซับซ้อนและง่ายต่อการแก้ไข
- **ตัวอย่างอีเวนต์:** `OnItemPurchased`, `OnCourseCompleted`, `OnSalaryPaid`

## 2.6. ระบบ UI (UI Management System)
- **UIManager:** คลาสที่จัดการการแสดงผลของ UI ทั้งหมด เช่น HUD (หน้าจอหลัก), หน้าต่างวางแผน, แดชบอร์ดการเงิน
- จะดักฟังอีเวนต์จากระบบต่างๆ เพื่ออัปเดตหน้าจอให้สอดคล้องกับข้อมูลล่าสุด

## 2.7. ระบบบันทึก/โหลดเกม (Save/Load System)
- **SaveLoadManager:** คลาสสำหรับจัดการการบันทึกข้อมูลเกมของผู้เล่น (เช่น `PlayerData`) ลงเป็นไฟล์ (JSON) และโหลดกลับขึ้นมา

---

# 3. โครงสร้างโปรเจกต์และมาตรฐานการเขียนโค้ด (Project Structure & Coding Standards)

## 3.1. โครงสร้างโฟลเดอร์ในโปรเจกต์ (Project Folder Structure)
เพื่อให้ง่ายต่อการค้นหาและจัดการไฟล์ เราจะใช้โครงสร้างดังนี้:
- **Assets/**
  - **_Project/** (ใช้ _ เพื่อให้โฟลเดอร์นี้อยู่บนสุดเสมอ)
    - **Art/** (ไฟล์กราฟิกทั้งหมด เช่น Sprites, UI, Animations)
    - **Audio/** (ไฟล์เสียงทั้งหมด เช่น Music, SFX)
    - **Prefabs/** (GameObjects ที่สร้างไว้ล่วงหน้า)
    - **Scenes/** (ไฟล์ Scene ทั้งหมดของเกม)
    - **ScriptableObjects/** (ไฟล์ข้อมูล ScriptableObject แยกตามประเภท)
    - **Scripts/**
      - **Core/** (สคริปต์ระบบหลัก เช่น GameManager, SaveLoadManager)
      - **Gameplay/** (สคริปต์ที่เกี่ยวกับกลไกเกม เช่น PlayerController, InflationManager)
      - **UI/** (สคริปต์ที่ควบคุม UI โดยเฉพาะ)
      - **Utilities/** (คลาสช่วยเหลือต่างๆ)
    - **Tests/** (ไฟล์เทสสำหรับ Edit Mode และ Play Mode)
  - **ThirdParty/** (สำหรับ Asset ที่ดาวน์โหลดจากภายนอก)

## 3.2. มาตรฐานการเขียนโค้ด (Coding Standards)
- **ภาษา:** C# 11
- **การตั้งชื่อ (Naming Conventions):**
  - **Classes, Enums, Public Methods/Properties:** `PascalCase`
  - **Private Fields:** `_camelCase` (ขึ้นต้นด้วย `_`)
  - **Interfaces:** `IMyInterface` (ขึ้นต้นด้วย `I`)
- **การคอมเมนต์:**
  - ใช้ XML Documentation Comments (`///`) สำหรับ Public methods และ classes ทุกอัน เพื่อให้ IDE แสดงคำอธิบายได้
  - คอมเมนต์อธิบายเฉพาะส่วนที่ซับซ้อน โดยเน้นอธิบายว่า "ทำไม" (Why) ไม่ใช่ "ทำอะไร" (What)
- **หลักการออกแบบ:** ยึดตามหลักการ SOLID เท่าที่ทำได้ เพื่อให้โค้ดมีความยืดหยุ่นและดูแลรักษาง่าย

## 3.3. การจัดการ Scene (Scene Management)
- จะมีคลาส `SceneLoader` กลางสำหรับจัดการการโหลด Scene แบบ Asynchronous เพื่อป้องกันเกมค้าง
- จะไม่ใช้ชื่อ Scene ที่เป็น String ในโค้ดโดยตรง แต่จะใช้ ScriptableObject หรือ Enum ในการอ้างอิงถึง Scene เพื่อลดความผิดพลาด

---

# 4. แผนการทดสอบและประสิทธิภาพ (Testing Plan & Performance)

## 4.1. กลยุทธ์การทดสอบ (Testing Strategy)
- **Unit Testing (Edit Mode):** จะใช้ Unity Test Framework ใน Edit Mode เพื่อทดสอบ Logic ของแต่ละคลาสที่ไม่ต้องรันในเกมจริง เช่น การคำนวณทางคณิตศาสตร์, การจัดการข้อมูล
- **Integration Testing (Play Mode):** จะใช้ Play Mode Test เพื่อทดสอบการทำงานร่วมกันของระบบต่างๆ เช่น ทดสอบว่าเมื่อผู้เล่นทำงานแล้ว ค่าเงินและเวลาถูกอัปเดตอย่างถูกต้องหรือไม่
- **Manual Playtesting:** จะมีการเล่นทดสอบจริงอย่างสม่ำเสมอเพื่อประเมินความสนุก, ความสมดุลของเกม, และหาบั๊กที่ไม่สามารถตรวจจับได้ด้วยการเทสอัตโนมัติ

## 4.2. เป้าหมายด้านประสิทธิภาพ (Performance Targets)
- **Framerate:** ตั้งเป้าหมายให้เกมรันที่ 60 FPS อย่างมีเสถียรภาพบนทุกแพลตฟอร์มเป้าหมาย
- **Memory Management:**
  - ลดการสร้างและทำลาย Object ที่ไม่จำเป็นเพื่อป้องกัน Garbage Collection (GC) Spikes ที่ทำให้เกมกระตุก
  - จะใช้เทคนิค **Object Pooling** กับ Object ที่ถูกสร้างบ่อยๆ เช่น ตัวเลขลอยขึ้นมาเวลาค่าสถานะเปลี่ยนแปลง
- **Loading Times:** เวลาในการโหลดเข้าเกมและระหว่าง Scene ต้องสั้นและไม่ทำให้ผู้เล่นรู้สึกว่าต้องรอนาน

## 4.3. จุดที่ต้องให้ความสำคัญในการ Optimize
- **UI Performance:** UI, โดยเฉพาะส่วนที่อัปเดตบ่อยๆ (เช่น ค่าสถานะ), ต้องถูกออกแบบมาให้มีผลกระทบต่อประสิทธิภาพน้อยที่สุด
- **Event-driven Logic:** การใช้ระบบอีเวนต์จะช่วยลดการทำงานที่ไม่จำเป็นในฟังก์ชัน `Update()` ซึ่งเป็นสาเหตุหลักของปัญหา Performance
- **Data Caching:** ข้อมูลที่ต้องใช้บ่อยๆ แต่ไม่เปลี่ยนแปลง จะถูกเก็บไว้ในหน่วยความจำ (Cache) เพื่อลดการคำนวณหรือการโหลดซ้ำๆ
