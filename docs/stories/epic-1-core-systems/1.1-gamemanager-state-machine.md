
# Story 1.1: Implement GameManager and State Machine (Phaser / TypeScript)

**Epic:** Core Systems & Player Foundation

## 1. Story
ในฐานะผู้เล่น (As a player), ฉันต้องการให้เกมมีระบบจัดการสถานะเกมที่มั่นคง (I want a stable game state management system) เพื่อให้เกมสามารถสลับสถานะและการทำงานระหว่างหน้าจอ/scene ต่างๆ เช่น เมนูหลัก, การเล่นเกม, และหน้าจอจบเกม ได้อย่างถูกต้องและราบรื่น (so that the game can correctly and smoothly handle transitions between different states like the main menu, gameplay, and game over).

> Note: This story is expressed as Phaser/TypeScript specific. The canonical implementation lives under `GameDev/Rich/src/` and uses TypeScript + Phaser 3 patterns (singleton module or scene plugin, and `Phaser.Events.EventEmitter` for notifications).

## 2. Acceptance Criteria (เกณฑ์การยอมรับ)
- [ ] มี `GameManager` module/file at `GameDev/Rich/src/GameManager.ts` (or a registered scene plugin) ที่ทำงานเป็น singleton และสามารถถูกเข้าถึงได้จากระบบอื่น
- [ ] เมื่อเกมเริ่ม ระบบต้องตั้งสถานะเริ่มต้นเป็น `MainMenu`
- [ ] สามารถเปลี่ยนสถานะจาก `MainMenu` → `GamePlaying` (เช่น เมื่อกด "Start") และ `GamePlaying` → `GameOver` (เมื่อเข้าเงื่อนไขพ่ายแพ้)
- [ ] GameManager ส่งเหตุการณ์/อีเวนต์เมื่อสถานะเปลี่ยน (ใช้ `Phaser.Events.EventEmitter` หรือเทียบเท่า) และระบบอื่นสามารถสมัครรับได้
- [ ] GameManager รักษาหรือให้การเข้าถึงสถานะเมื่อเปลี่ยน Scene (ใน Phaser: ผ่าน singleton export, registry, หรือ scene plugin pattern)

## 3. Tasks / Subtasks (งานย่อย)
- [ ] **1. สร้าง GameManager as TypeScript module:**
  - [ ] 1.1. สร้าง `GameDev/Rich/src/GameManager.ts` (TypeScript)
  - [ ] 1.2. ใช้ Singleton Pattern (exported instance) หรือ Scene Plugin หากต้องการ tight integration กับ Phaser scenes
  - [ ] 1.3. ใช้ `Phaser.Events.EventEmitter` (composition) เพื่อออกอีเวนต์เมื่อสถานะเปลี่ยน

- [ ] **2. กำหนด Game States:**
  - [ ] 2.1. สร้าง `export enum GameState { MainMenu, GamePlaying, Paused, GameOver }` ใน `GameManager.ts` หรือไฟล์แยก
  - [ ] 2.2. ใน `GameManager`, สร้าง `public get currentState(): GameState` และเมธอดที่เปลี่ยนสถานะอย่างปลอดภัย

- [ ] **3. พัฒนากลไก State Machine:**
  - [ ] 3.1. สร้าง `private changeState(newState: GameState)` เพื่อจัดการ transition และ lifecycle hooks (onEnter/onExit) แบบง่าย
  - [ ] 3.2. สร้าง `onGameStateChanged: Phaser.Events.EventEmitter` หรือ `EventEmitter`-like API และกระจายเหตุการณ์เมื่อสถานะเปลี่ยน
  - [ ] 3.3. สร้างเมธอดสาธารณะสำหรับการใช้งาน: `startNewGame()`, `pauseGame()`, `goToMainMenu()`, `endGame()`

- [ ] **4. Integration / Boot:**
  - [ ] 4.1. ลงทะเบียน/นำเข้า `GameManager` ใน `GameDev/Rich/src/main.ts` หรือใน boot scene เพื่อให้แน่ใจว่าสามารถเข้าถึงได้จากทุก scene
  - [ ] 4.2. ถ้าใช้ Scene Plugin ให้ลงทะเบียนเป็น plugin ใน game config

- [ ] **5. เขียน Unit Tests (Jest):**
  - [ ] 5.1. เขียนเทสเพื่อยืนยันว่า `GameManager` ถูก export เป็น singleton (หรือ behavior เทียบเท่า)
  - [ ] 5.2. เขียนเทสเพื่อยืนยันว่าสถานะเริ่มต้นคือ `MainMenu`
  - [ ] 5.3. เขียนเทสเพื่อยืนยันว่าการเรียกเมธอดเปลี่ยนสถานะจะเปลี่ยน `currentState` และยิงอีเวนต์ที่ถูกต้อง (mock `Phaser` ใน jest setup ตาม repo pattern)

## 4. Dev Notes (บันทึกสำหรับนักพัฒนา)
- Prefer composition over inheriting Phaser.Scene for testability: keep GameManager as plain TS class using `Phaser.Events.EventEmitter` so it can be unit-tested without a full Phaser runtime.
- Location suggestions: `GameDev/Rich/src/GameManager.ts`, tests in `GameDev/Rich/src/GameManager.test.ts` (jest + jsdom + necessary Phaser mocks already present in repo).

## 5. QA / Testing Notes (บันทึกสำหรับ QA และการทดสอบ)
- ทดสอบการเปลี่ยน scene/transition ให้แน่ใจว่า GameManager ยังคงให้สถานะที่ถูกต้องเมื่อสลับ scenes (ใน Phaser: test via singleton access or scene registry).
- ตรวจสอบว่า event `onGameStateChanged` ถูกส่งออกพร้อมข้อมูล state ที่ถูกต้องทุกครั้ง
- สำหรับ unit/integration tests: ใช้ existing `jest.setup.js` และ mocks ใน `GameDev/Rich` to simulate Phaser runtime where needed

## 6. Dependencies (สตอรี่ที่เกี่ยวข้อง)
- *ยังไม่มี*

---
## Dev Agent Record
- **Agent Model Used:** Gemini
- **Debug Log References:**
  - Initial project setup in `GameDev/Rich` folder.
  - Implemented `GameManager` as a TypeScript Singleton with `GameState` enum and state machine logic.
  - Used composition for `Phaser.Events.EventEmitter` to handle events, making `GameManager` testable.
  - Integrated `GameManager` into `main.ts` for demonstration.
  - Set up Jest for unit testing.
  - Resolved `package.json` JSON syntax error.
  - Resolved Jest `window is not defined` error by using `jsdom` environment.
  - Resolved Jest `jest-environment-jsdom` not found error by installing it.
  - Resolved Jest `HTMLCanvasElement.prototype.getContext` and `TypeError` by mocking Phaser globally for tests and using composition in `GameManager`.
  - All unit tests for `GameManager` in `GameDev/Rich` passed successfully (see `GameDev/Rich/src/GameManager.test.ts`).
- **Completion Notes:**
  - Implemented `GameManager` and State Machine according to the story using TypeScript + Phaser patterns. Core functionality and tests live under `GameDev/Rich/src/`.
  - The `GameManager` is a singleton (exported instance), manages game states, and emits events on state changes.
  - Persistence across scenes is achieved via the exported singleton/registry pattern in Phaser.
- **File List (relevant):**
  - `GameDev/Rich/package.json`
  - `GameDev/Rich/tsconfig.json`
  - `GameDev/Rich/webpack.config.js`
  - `GameDev/Rich/index.html`
  - `GameDev/Rich/src/main.ts`
  - `GameDev/Rich/src/GameManager.ts`
  - `GameDev/Rich/jest.config.js`
  - `GameDev/Rich/jest.setup.js`
  - `GameDev/Rich/src/GameManager.test.ts`
  - `.gitignore` (updated)
- **Change Log:**
  - Converted story to Phaser/TypeScript specific guidance and updated tasks, acceptance criteria, and QA notes to match `GameDev/Rich` implementation.