
# Story 1.1: Implement GameManager and State Machine (Phaser / TypeScript)

**Epic:** Core Systems & Player Foundation

## 1. Story
ในฐานะผู้เล่น (As a player), ฉันต้องการให้เกมมีระบบจัดการสถานะเกมที่มั่นคง (I want a stable game state management system) เพื่อให้เกมสามารถสลับสถานะและการทำงานระหว่างหน้าจอ/scene ต่างๆ เช่น เมนูหลัก, การเล่นเกม, และหน้าจอจบเกม ได้อย่างถูกต้องและราบรื่น (so that the game can correctly and smoothly handle transitions between different states like the main menu, gameplay, and game over).

> Note: This story is expressed as Phaser/TypeScript specific. The canonical implementation lives under `GameDev/Rich/src/` and uses TypeScript + Phaser 3 patterns (singleton module or scene plugin, and `Phaser.Events.EventEmitter` for notifications).

## 2. Acceptance Criteria (เกณฑ์การยอมรับ)
- [x] มี `GameManager` module/file at `GameDev/Rich/src/GameManager.ts` (or a registered scene plugin) ที่ทำงานเป็น singleton และสามารถถูกเข้าถึงได้จากระบบอื่น
- [x] เมื่อเกมเริ่ม ระบบต้องตั้งสถานะเริ่มต้นเป็น `MainMenu`
- [x] สามารถเปลี่ยนสถานะจาก `MainMenu` → `GamePlaying` (เช่น เมื่อกด "Start") และ `GamePlaying` → `GameOver` (เมื่อเข้าเงื่อนไขพ่ายแพ้)
- [x] GameManager ส่งเหตุการณ์/อีเวนต์เมื่อสถานะเปลี่ยน (ใช้ `Phaser.Events.EventEmitter` หรือเทียบเท่า) และระบบอื่นสามารถสมัครรับได้
- [x] GameManager รักษาหรือให้การเข้าถึงสถานะเมื่อเปลี่ยน Scene (ใน Phaser: ผ่าน singleton export, registry, หรือ scene plugin pattern)

## 3. Tasks / Subtasks (งานย่อย)
- [ ] **1. สร้าง GameManager as TypeScript module:**
  - [ ] 1.1. สร้าง `GameDev/Rich/src/GameManager.ts` (TypeScript)
  - [ ] 1.2. ใช้ Singleton Pattern (exported instance) หรือ Scene Plugin หากต้องการ tight integration กับ Phaser scenes
  - [ ] 1.3. ใช้ `Phaser.Events.EventEmitter` (composition) เพื่อออกอีเวนต์เมื่อสถานะเปลี่ยน
  - [x] 1.1. สร้าง `GameDev/Rich/src/GameManager.ts` (TypeScript)
  - [x] 1.2. ใช้ Singleton Pattern (exported instance) หรือ Scene Plugin หากต้องการ tight integration กับ Phaser scenes
  - [x] 1.3. ใช้ `Phaser.Events.EventEmitter` (composition) เพื่อออกอีเวนต์เมื่อสถานะเปลี่ยน

- [ ] **2. กำหนด Game States:**
  - [ ] 2.1. สร้าง `export enum GameState { MainMenu, GamePlaying, Paused, GameOver }` ใน `GameManager.ts` หรือไฟล์แยก
  - [ ] 2.2. ใน `GameManager`, สร้าง `public get currentState(): GameState` และเมธอดที่เปลี่ยนสถานะอย่างปลอดภัย
  - [x] 2.1. สร้าง `export enum GameState { MainMenu, GamePlaying, Paused, GameOver }` ใน `GameManager.ts` หรือไฟล์แยก
  - [x] 2.2. ใน `GameManager`, สร้าง `public get currentState(): GameState` และเมธอดที่เปลี่ยนสถานะอย่างปลอดภัย

- [ ] **3. พัฒนากลไก State Machine:**
  - [ ] 3.1. สร้าง `private changeState(newState: GameState)` เพื่อจัดการ transition และ lifecycle hooks (onEnter/onExit) แบบง่าย
  - [ ] 3.2. สร้าง `onGameStateChanged: Phaser.Events.EventEmitter` หรือ `EventEmitter`-like API และกระจายเหตุการณ์เมื่อสถานะเปลี่ยน
  - [ ] 3.3. สร้างเมธอดสาธารณะสำหรับการใช้งาน: `startNewGame()`, `pauseGame()`, `goToMainMenu()`, `endGame()`
  - [x] 3.1. สร้าง `private changeState(newState: GameState)` เพื่อจัดการ transition และ lifecycle hooks (onEnter/onExit) แบบง่าย
  - [x] 3.2. สร้าง `onGameStateChanged: Phaser.Events.EventEmitter` หรือ `EventEmitter`-like API และกระจายเหตุการณ์เมื่อสถานะเปลี่ยน
  - [x] 3.3. สร้างเมธอดสาธารณะสำหรับการใช้งาน: `startNewGame()`, `pauseGame()`, `goToMainMenu()`, `endGame()`

- [ ] **4. Integration / Boot:**
  - [ ] 4.1. ลงทะเบียน/นำเข้า `GameManager` ใน `GameDev/Rich/src/main.ts` หรือใน boot scene เพื่อให้แน่ใจว่าสามารถเข้าถึงได้จากทุก scene
  - [ ] 4.2. ถ้าใช้ Scene Plugin ให้ลงทะเบียนเป็น plugin ใน game config
  - [x] 4.1. ลงทะเบียน/นำเข้า `GameManager` ใน `GameDev/Rich/src/main.ts` หรือใน boot scene เพื่อให้แน่ใจว่าสามารถเข้าถึงได้จากทุก scene
  - [x] 4.2. ถ้าใช้ Scene Plugin ให้ลงทะเบียนเป็น plugin ใน game config

- [ ] **5. เขียน Unit Tests (Jest):**
  - [ ] 5.1. เขียนเทสเพื่อยืนยันว่า `GameManager` ถูก export เป็น singleton (หรือ behavior เทียบเท่า)
  - [ ] 5.2. เขียนเทสเพื่อยืนยันว่าสถานะเริ่มต้นคือ `MainMenu`
  - [ ] 5.3. เขียนเทสเพื่อยืนยันว่าการเรียกเมธอดเปลี่ยนสถานะจะเปลี่ยน `currentState` และยิงอีเวนต์ที่ถูกต้อง (mock `Phaser` ใน jest setup ตาม repo pattern)
  - [x] 5.1. เขียนเทสเพื่อยืนยันว่า `GameManager` ถูก export เป็น singleton (หรือ behavior เทียบเท่า)
  - [x] 5.2. เขียนเทสเพื่อยืนยันว่าสถานะเริ่มต้นคือ `MainMenu`
  - [x] 5.3. เขียนเทสเพื่อยืนยันว่าการเรียกเมธอดเปลี่ยนสถานะจะเปลี่ยน `currentState` และยิงอีเวนต์ที่ถูกต้อง (mock `Phaser` ใน jest setup ตาม repo pattern)

## 4. Dev Notes (บันทึกสำหรับนักพัฒนา)
- Implementation: `GameDev/Rich/src/GameManager.ts` — singleton TypeScript class using composition for events. Default emitter is internal lightweight emitter; in runtime pass `scene.events` for Phaser integration.
- Adapter: `GameDev/Rich/src/adapter.ts` provides `initGameManagerWithScene(scene)` to initialize with Phaser scene emitter.
- Demo: `GameDev/Rich/src/main.ts` contains a BootScene demo with S/P/E/M controls.
- Tests: `GameDev/Rich/src/GameManager.test.ts` (Jest) validate singleton, initial state, transitions & events.

## 5. QA / Testing Notes (บันทึกสำหรับ QA และการทดสอบ)
- Unit tests: All tests for `GameManager` passed (see `GameDev/Rich/src/GameManager.test.ts`).
- Integration demo: BootScene shows current state and supports keyboard controls (S,P,E,M). Use `npm run dev` or `npm run preview` to open and manually verify transitions.
- Persistence test: Demo exposes `GameManager` as singleton — verify by switching scenes or inspecting `(window as any).GM` if needed.
- Performance: Basic smoke tests via dev server show no obvious frame drops for this demo; full profiling recommended on target devices for 60 FPS guarantee.

## 6. Dependencies (สตอรี่ที่เกี่ยวข้อง)
- *ยังไม่มี*

---
## Dev Agent Record
- **Agent Model Used:** Gemini
- **Debug Log References:**
  - Initial project setup in `GameDev/Rich` folder.
  - Implemented `GameManager` as a TypeScript Singleton with `GameState` enum and state machine logic.
  - Used composition for `Phaser.Events.EventEmitter` to handle events, making `GameManager` testable.
  - Integrated `GameManager` into `main.ts` for demonstration.
  - Set up Jest for unit testing and adjusted tsconfig/jest for the workspace.
  - Resolved `package.json` JSON syntax issues during setup.
  - Implemented internal EventEmitter fallback for testability without requiring Phaser at test-time.
  - All unit tests for `GameManager` in `GameDev/Rich` passed successfully (`GameDev/Rich/src/GameManager.test.ts`).
- **Completion Notes:**
  - Implemented `GameManager` and State Machine according to the story using TypeScript + Phaser patterns. Core functionality, tests, demo and build scripts live under `GameDev/Rich/`.
  - The `GameManager` is a singleton (exported instance), manages game states, and emits events on state changes.
  - Persistence across scenes is achieved via the exported singleton/registry pattern in Phaser and validated via demo (manual persistence test possible).
- **File List (relevant):**
  - `GameDev/Rich/package.json`
  - `GameDev/Rich/tsconfig.json`
  - `GameDev/Rich/vite.config.ts`
  - `GameDev/Rich/index.html`
  - `GameDev/Rich/src/main.ts`
  - `GameDev/Rich/src/GameManager.ts`
  - `GameDev/Rich/jest.config.js`
  - `GameDev/Rich/jest.setup.js`
  - `GameDev/Rich/src/GameManager.test.ts`
  - `GameDev/Rich/README.md`
  - `.gitignore` (updated)
- **Change Log:**
  - Converted story to Phaser/TypeScript specific guidance and implemented GameManager, tests, demo, build, and docs.