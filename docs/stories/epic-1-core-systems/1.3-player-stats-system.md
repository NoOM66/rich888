# Story 1.3: Implement Player Stats System

**Epic:** Core Systems & Player Foundation

## 1. Story
ในฐานะผู้เล่น (As a player), ฉันต้องการระบบที่คอยจัดการค่าสถานะหลักของตัวละคร (Money, Health, Happiness, Education, และ Stress) (I need a system that manages my character's core stats) เพื่อให้การกระทำของฉันส่งผลอย่างมีความหมาย และฉันสามารถติดตามความคืบหน้าในการไปสู่เป้าหมายของเกมได้ (so that my actions have meaningful consequences and I can track my progress towards the game's goals).

## 2. Acceptance Criteria (เกณฑ์การยอมรับ)
- [ ] มี `PlayerStatsController.cs` Script ในโปรเจกต์
- [ ] ระบบสามารถติดตามค่าสถานะได้ 5 อย่าง: Money, Health, Happiness, Education, และ Stress
- [ ] ค่าสถานะแต่ละอย่างมีค่าต่ำสุด (0) และค่าสูงสุดที่กำหนดไว้
- [ ] มีฟังก์ชัน Public สำหรับเพิ่ม/ลดค่าสถานะแต่ละอย่างโดยเฉพาะ (เช่น `AddMoney(float amount)`, `DecreaseHealth(float amount)`)
- [ ] ทุกครั้งที่มีการเปลี่ยนแปลงค่าสถานะ, จะต้องมีการยิง Event `OnStatChanged` ออกมา (พร้อมระบุว่าค่าไหนเปลี่ยนไป, ค่าเก่าคืออะไร, ค่าใหม่คืออะไร) เพื่อให้ระบบ UI และระบบอื่นๆ นำไปใช้ต่อได้
- [ ] ข้อมูลค่าสถานะทั้งหมดถูกเก็บในคลาส `PlayerData` ซึ่งง่ายต่อการนำไปบันทึกและโหลด
- [ ] หากค่า Health หรือ Happiness ลดลงเหลือ 0, ระบบจะต้องยิง Event `OnPlayerLost` เพื่อแจ้งให้ `GameManager` ทราบว่าผู้เล่นแพ้แล้ว

## 3. Tasks / Subtasks (งานย่อย)
- [ ] **1. สร้างโครงสร้างข้อมูลสำหรับผู้เล่น:**
  - [ ] 1.1. สร้าง C# Script ใหม่ชื่อ `PlayerData.cs` (ไม่ต้องสืบทอดจาก MonoBehaviour)
  - [ ] 1.2. ใน `PlayerData`, สร้าง public fields สำหรับ `Money`, `Health`, `Happiness`, `Education`, `Stress`
  - [ ] 1.3. กำหนดให้คลาสเป็น `[System.Serializable]` เพื่อให้สามารถบันทึกเป็นไฟล์ได้

- [ ] **2. สร้าง Controller จัดการค่าสถานะ:**
  - [ ] 2.1. สร้าง C# Script ใหม่ชื่อ `PlayerStatsController.cs` และทำให้เป็น Singleton
  - [ ] 2.2. ให้ `PlayerStatsController` ถือ instance ของ `PlayerData` ไว้

- [ ] **3. พัฒนาฟังก์ชันสำหรับเพิ่ม/ลดค่าสถานะ:**
  - [ ] 3.1. สร้างฟังก์ชัน Public สำหรับจัดการค่าสถานะแต่ละอย่าง เช่น `public void AddMoney(float amount)`, `public void ApplyHealthChange(float amount)`
  - [ ] 3.2. ในฟังก์ชันเหล่านี้ ต้องมีการ clamp ค่าไม่ให้เกิน min/max ที่กำหนดไว้
  - [ ] 3.3. หลังจากเปลี่ยนแปลงค่า ต้องเรียกใช้ Event `OnStatChanged`

- [ ] **4. เชื่อมต่อกับระบบ Event:**
  - [ ] 4.1. สร้าง `public static event Action<StatType, float> OnStatChanged;` (ส่งประเภทของค่าสถานะ และค่าใหม่ไปด้วย)
  - [ ] 4.2. สร้าง `public static event Action OnPlayerLost;`
  - [ ] 4.3. ตรวจสอบเงื่อนไขการแพ้ (Health/Happiness <= 0) และเรียกใช้ `OnPlayerLost`

- [ ] **5. เตรียมฟังก์ชันสำหรับระบบ Save/Load:**
  - [ ] 5.1. สร้างฟังก์ชัน `public PlayerData GetPlayerData()` สำหรับให้ `SaveLoadManager` นำข้อมูลไปบันทึก
  - [ ] 5.2. สร้างฟังก์ชัน `public void LoadPlayerData(PlayerData data)` สำหรับรับข้อมูลที่โหลดมา

- [ ] **6. เขียน Unit Tests:**
  - [ ] 6.1. เทสฟังก์ชันเพิ่ม/ลดค่าสถานะ ว่าทำงานถูกต้อง
  - [ ] 6.2. เทสว่าค่าสถานะถูก clamp ไว้ในขอบเขต min/max จริง
  - [ ] 6.3. เทสว่า Event `OnStatChanged` และ `OnPlayerLost` ถูกเรียกใช้ในเงื่อนไขที่ถูกต้อง

## 4. Dev Notes (บันทึกสำหรับนักพัฒนา)
- ระบบนี้เป็นหัวใจสำคัญของข้อมูลผู้เล่น ควรออกแบบให้ยืดหยุ่นเผื่อมีการเพิ่มค่าสถานะใหม่ๆ ในอนาคต
- การแยก `PlayerData` ออกจาก `PlayerStatsController` (MonoBehaviour) เป็นสิ่งสำคัญเพื่อให้ง่ายต่อการทดสอบและบันทึกข้อมูล

## 5. QA / Testing Notes (บันทึกสำหรับ QA และการทดสอบ)
- ทดสอบทุกเงื่อนไขของการเพิ่ม/ลดค่าสถานะ โดยเฉพาะค่าติดลบและค่าที่เกิน max
- ทดสอบเงื่อนไขการแพ้ (Health = 0, Happiness = 0) ว่า `OnPlayerLost` ถูกเรียกและ `GameManager` ตอบสนองโดยการเปลี่ยน State เป็น `GameOver`

## 6. Dependencies (สตอรี่ที่เกี่ยวข้อง)
- **Story 1.1: Implement GameManager and State Machine:** `PlayerStatsController` ต้องส่ง Event `OnPlayerLost` ให้ `GameManager` เพื่อเปลี่ยนสถานะเกม
- **Story 1.4: Implement Save/Load System:** `SaveLoadManager` จะต้องเรียกใช้ฟังก์ชันใน `PlayerStatsController` เพื่อบันทึกและโหลดข้อมูล

---
## Dev Agent Record
- **Agent Model Used:**
- **Debug Log References:**
- **Completion Notes:**
- **File List:**
- **Change Log:**
