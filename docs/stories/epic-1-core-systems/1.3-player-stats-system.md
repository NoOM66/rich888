# Story 1.3: Implement Player Stats System

**Epic:** Core Systems & Player Foundation

## 1. Story
ในฐานะผู้เล่น (As a player), ฉันต้องการระบบที่คอยจัดการค่าสถานะหลักของตัวละคร (Money, Health, Happiness, Education, และ Stress) (I need a system that manages my character's core stats) เพื่อให้การกระทำของฉันส่งผลอย่างมีความหมาย และฉันสามารถติดตามความคืบหน้าในการไปสู่เป้าหมายของเกมได้ (so that my actions have meaningful consequences and I can track my progress towards the game's goals).

## 2. Acceptance Criteria (เกณฑ์การยอมรับ)
- [x] มี `PlayerStatsController.cs` Script ในโปรเจกต์
- [x] ระบบสามารถติดตามค่าสถานะได้ 5 อย่าง: Money, Health, Happiness, Education, และ Stress
- [x] ค่าสถานะแต่ละอย่างมีค่าต่ำสุด (0) และค่าสูงสุดที่กำหนดไว้
- [x] มีฟังก์ชัน Public สำหรับเพิ่ม/ลดค่าสถานะแต่ละอย่างโดยเฉพาะ (เช่น `AddMoney(float amount)`, `DecreaseHealth(float amount)`)
- [x] ทุกครั้งที่มีการเปลี่ยนแปลงค่าสถานะ, จะต้องมีการยิง Event `OnStatChanged` ออกมา (พร้อมระบุว่าค่าไหนเปลี่ยนไป, ค่าเก่าคืออะไร, ค่าใหม่คืออะไร) เพื่อให้ระบบ UI และระบบอื่นๆ นำไปใช้ต่อได้
- [x] ข้อมูลค่าสถานะทั้งหมดถูกเก็บในคลาส `PlayerData` ซึ่งง่ายต่อการนำไปบันทึกและโหลด
- [x] หากค่า Health หรือ Happiness ลดลงเหลือ 0, ระบบจะต้องยิง Event `OnPlayerLost` เพื่อแจ้งให้ `GameManager` ทราบว่าผู้เล่นแพ้แล้ว

## 3. Tasks / Subtasks (งานย่อย)
- [x] **1. สร้างโครงสร้างข้อมูลสำหรับผู้เล่น:**
  - [x] 1.1. สร้าง C# Script ใหม่ชื่อ `PlayerData.cs` (ไม่ต้องสืบทอดจาก MonoBehaviour)
  - [x] 1.2. ใน `PlayerData`, สร้าง public fields สำหรับ `Money`, `Health`, `Happiness`, `Education`, `Stress`
  - [x] 1.3. กำหนดให้คลาสเป็น `[System.Serializable]` เพื่อให้สามารถบันทึกเป็นไฟล์ได้

- [x] **2. สร้าง Controller จัดการค่าสถานะ:**
  - [x] 2.1. สร้าง C# Script ใหม่ชื่อ `PlayerStatsController.cs` และทำให้เป็น Singleton
  - [x] 2.2. ให้ `PlayerStatsController` ถือ instance ของ `PlayerData` ไว้

- [x] **3. พัฒนาฟังก์ชันสำหรับเพิ่ม/ลดค่าสถานะ:**
  - [x] 3.1. สร้างฟังก์ชัน Public สำหรับจัดการค่าสถานะแต่ละอย่าง เช่น `public void AddMoney(float amount)`, `public void ApplyHealthChange(float amount)`
  - [x] 3.2. ในฟังก์ชันเหล่านี้ ต้องมีการ clamp ค่าไม่ให้เกิน min/max ที่กำหนดไว้
  - [x] 3.3. หลังจากเปลี่ยนแปลงค่า ต้องเรียกใช้ Event `OnStatChanged`

- [x] **4. เชื่อมต่อกับระบบ Event:**
  - [x] 4.1. สร้าง `public static event Action<StatType, float> OnStatChanged;` (ส่งประเภทของค่าสถานะ และค่าใหม่ไปด้วย)
  - [x] 4.2. สร้าง `public static event Action OnPlayerLost;`
  - [x] 4.3. ตรวจสอบเงื่อนไขการแพ้ (Health/Happiness <= 0) และเรียกใช้ `OnPlayerLost`

- [x] **5. เตรียมฟังก์ชันสำหรับระบบ Save/Load:**
  - [x] 5.1. สร้างฟังก์ชัน `public PlayerData GetPlayerData()` สำหรับให้ `SaveLoadManager` นำข้อมูลไปบันทึก
  - [x] 5.2. สร้างฟังก์ชัน `public void LoadPlayerData(PlayerData data)` สำหรับรับข้อมูลที่โหลดมา

- [x] **6. เขียน Unit Tests:**
  - [x] 6.1. เทสฟังก์ชันเพิ่ม/ลดค่าสถานะ ว่าทำงานถูกต้อง
  - [x] 6.2. เทสว่าค่าสถานะถูก clamp ไว้ในขอบเขต min/max จริง
  - [x] 6.3. เทสว่า Event `OnStatChanged` และ `OnPlayerLost` ถูกเรียกใช้ในเงื่อนไขที่ถูกต้อง

## 4. Dev Notes (บันทึกสำหรับนักพัฒนา)
- ระบบนี้เป็นหัวใจสำคัญของข้อมูลผู้เล่น ควรออกแบบให้ยืดหยุ่นเผื่อมีการเพิ่มค่าสถานะใหม่ๆ ในอนาคต
- การแยก `PlayerData` ออกจาก `PlayerStatsController` (MonoBehaviour) เป็นสิ่งสำคัญเพื่อให้ง่ายต่อการทดสอบและบันทึกข้อมูล

## 5. QA / Testing Notes (บันทึกสำหรับ QA และการทดสอบ)
- ทดสอบทุกเงื่อนไขของการเพิ่ม/ลดค่าสถานะ โดยเฉพาะค่าติดลบและค่าที่เกิน max
- ทดสอบเงื่อนไขการแพ้ (Health = 0, Happiness = 0) ว่า `OnPlayerLost` ถูกเรียกและ `GameManager` ตอบสนองโดยการเปลี่ยน State เป็น `GameOver`

## 6. Dependencies (สตอรี่ที่เกี่ยวข้อง)
- **Story 1.1: Implement GameManager and State Machine:** `PlayerStatsController` ต้องส่ง Event `OnPlayerLost` ให้ `GameManager` เพื่อเปลี่ยนสถานะเกม
- **Story 1.4: Implement Save/Load System:** `SaveLoadManager` จะต้องเรียกใช้ฟังก์ชันใน `PlayerStatsController` เพื่อบันทึกและโหลดข้อมูล

---
## Dev Agent Record
- **Agent Model Used:** Gemini
- **Debug Log References:**
  - Implemented `PlayerData.ts` for player data structure.
  - Implemented `StatType.ts` enum for stat types.
  - Implemented `PlayerStatsController.ts` as a TypeScript Singleton.
  - Integrated `PlayerStatsController` with `GameManager` by calling `gameOver()` on `onPlayerLost` event.
  - Added UI elements in `main.ts` to display player stats and buttons to manipulate them.
  - Wrote comprehensive unit tests for `PlayerStatsController` covering all specified tasks and acceptance criteria.
  - Resolved multiple TypeScript and Jest mocking issues during unit testing of `PlayerStatsController`.
  - All 30 unit tests for `PlayerStatsController`, `TurnManager`, and `GameManager` passed successfully.
- **Completion Notes:**
  - Implemented the Player Stats System according to the story, adapting C#/.NET concepts to TypeScript/Phaser.
  - The system tracks Money, Health, Happiness, Education, and Stress with min/max clamping.
  - It correctly emits `onStatChanged` and `onPlayerLost` events.
  - It integrates with `GameManager` to change game state on player loss.
  - The core functionality is complete and unit-tested.
- **File List:**
  - `GameDev/Rich/src/PlayerData.ts`
  - `GameDev/Rich/src/StatType.ts`
  - `GameDev/Rich/src/PlayerStatsController.ts`
  - `GameDev/Rich/src/PlayerStatsController.test.ts`
  - `GameDev/Rich/src/main.ts` (updated)
- **Change Log:**
  - Initial implementation of Player Stats System.
  - Integration with GameManager.
  - Unit tests for Player Stats System.